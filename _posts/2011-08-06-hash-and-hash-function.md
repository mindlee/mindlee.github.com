---
title: 散列及散列函数
author: Wei Li
excerpt: 散列表就是哈希表，散列表的实现叫做散列, 散列的英文是：Hash。散列是一种用于常数平均时间执行插入、删除和查找的技术。
meta_description: 散列表就是哈希表，散列表的实现叫做散列, 散列的英文是：Hash。散列是一种用于常数平均时间执行插入、删除和查找的技术。
layout: post
permalink: /2011/08/06/hash-and-hash-function/
views:
  - 5878
categories:
  - 算法学习
tags:
  - 散列
  - 数据结构
  - 笔记
  - 算法
  - 算法导论
---
### 散列是什么？

散列表就是哈希表，散列表的实现叫做散列, 散列的英文是：Hash。**散列是一种用于常数平均时间执行插入、删除和查找的技术。**
         
	子问题：什么是散列表？
	把标识符储存在一个固定的表中，该表被称为散列表。

散列表其实也是一种查找类型的数据结构，它和树的区别在于，树是在一定范围内查找符合关键字的内容，而散列表则是从全表来查找符合的内容。这样一对比好象是树的结构要比散列表更好些，其实不然。**树的查找快捷是建立在内容已排好序的基础上的，而散列表则是在无序表中通过关键字来实现快捷查找。**

简单的说下散列表的工作方法，首先建立一张足够大的表，插入内容时将输入的关键字通过散列函数进行换算，变成表的行号，然后将内容存入这个行号对应的行中。查找时亦然，通过将要查找的关键字进行换算，变成表的行号，然后从表中这个行号对应的行中提取信息。


### 散列有什么用？

>（以下摘自《数据结构与算法分析》）

>散列的应用很广。**编译器使用散列表跟踪源代码中声明的变量**，这种数据结构叫做符号表(symbol table)。散列表时这种问题的理想选择。标识符一般都不长，因此散列函数能够迅速完成运算。此外，按字母顺序排序变量通常也是不必要的。

>**散列表适用于任何其节点有实名而不是数字名的图论问题**。这里，当输入被读入的时候，定点则按照它们出现的顺序从1开始指定为一些整数。再有，输入很可能有一组按字母顺序排列的项。例如，顶点可以是计算机。此时，如果一个特定的计算中心把它的计算机列表成ibm1,ibm2,ibm3…那么，若使用查找树则在效率方面很可能会有戏剧性的结果。

>**散列表的第三种常见的用途实在为游戏编制的程序中**。当程序搜索游戏的不同的运动路径时，它通过计算基于位置的散列函数而跟踪一些已知的位置(并把对于该位置的移动存储起来)。如果同样的位置再次出现，程序通常通过简单的移动变换来避免昂贵的重复计算。游戏程序的这种一般特点叫做置换表(transposition table）.

>**散列的另一个用途是在线拼写检查程序**。如果拼写检查程序的主要功能是检查拼写错误(而非纠正错误),那么可以预先将整个词典进行散列，这样就可以在常数时间内检查单词拼写。散列表很适合这项工作，因为以字母顺序排列单词并不重要，而以它们在文件中出现的顺序显示错误拼写当然也是可以接受的。

### 如何设计一个好的散列函数？
	子问题：什么是散列函数？
	散列函数f把标识符x转换为散列表中的散列地址。

散列函数的关键字既有数字，也有字符串，比如上边所说的预先将整个词典进行散列……如果是数字，OK， 如果是字符串，可以先转化为整数：

例如，标示符(字符)pt可以解释为（112， 116）（ASCII），然后按128为基数，pt即为：（112 * 128 + 116）= 14452

常用散列方法：

### 第一种：除法散列：

通过取k除以m的余数，来将关键字k映射到m个槽的某一个中去，亦即，散列函数为：

**h(k) = k mod m；**

当应用除法散列时，要注意m的选择。例如，m不应是2的幂，因为如果m = 2 ^ p, 则 h(k)就是k的p个最低位数字。

可以选作m的值为与2的整数幂不太 接近的质数。

**为什么是质数？**不是很懂，算法导论里一句带过，也可能是我没看懂 （看懂的指教下我），原话是：“m不应是2的幂，因为如果m = 2 ^ p, 则h(k)就是k的p个最低位数字”，后来翻《数据结构》（不是严奶奶那本）, 里边提到原因是：Knuth证明了当M可以整除数 r^k + a时，其中a和k都是小整数，r是字符集的基数，则X % M趋向于是X中字符的简单叠加。因此，选择M的较好方法是：M首先是一个素数，且对于小整数k和a，M不能整除r^k + a，经验表明：在实际应用中，可以选择满足上述条件且没有小于20的素因子的M

### 第二种：乘法散列：
用关键字k先乘上A，然后取出kA的小数部分，然后用m乘以这个值，再取结果的底（floor）。

    散列函数是：
		h(k) = floor(m * (k A % 1))；

根据研究，Knuth【185】认为 A 取(sqrt(5)-1) / 2是一个比较理想的值

所以代码实现就相当简单了：

PS：乘法里，m的选择没有特别的要求，一般选择它的2的某个幂次（虽然书上没说为什么，但是应该想到答案了吧，因为如果是2的整数幂，可以直接用移位运算，可以减少运行时间，如果不是，则必然是乘法，这个可是很耗资源的）

{% highlight c %}
int Hash (int k) {
    return (1 << 5) * (k * A - floor(k * A));
}
{% endhighlight %}
### 第三种：全域散列：

全域散列用的方法是：随机地选择散列函数，使之独立于要存储的关键字，这样就很难出现最坏情况，平均性能很好。

最后设计了一个是：h(a,b) = ((ak + b)  mod  p) mod m；

（木有看懂过程，就不列出过程了，看《算法导论》吧）

最后，上代码（基本来自《数据结构和算法分析》）；

最简单的散列函数，字符直接求和，取模，可以很快否定，如果表很大，如TableSize = 10007, 并设所有关键字至多8个字符长，由于char类型的值最多是127， 因此散列函数只能取值0和1016 == 127 * 8之间的数，显然不均匀。

{% highlight c %}
unsigned int Hash(const char *Key, int TableSize) {
    unsigned int HashVal = 0;
    while (*key != '\0') {
        HashVal += *Key++;
    }
    return HashVal % TableSize;
}
{% endhighlight %}
改进1：
{% highlight c %}
unsigned int Hash(const char *Key, int TableSize) {
    return (Key[0] + 27 * Key[1] + 729 * Key[2]);
}
{% endhighlight %}
该函数只考察前三个字符，这样，可以有26 ^ 3 = 17576中可能组合，上边的表可以符合，但是事实上3个字母不同组合数实际只有2851种，所以表只有28%被利用。虽然很容易计算，但散列表足够大时这个函数还是不适合的。

改进2：

通常实际真正用到的很可能只有26个字母，外加一个空字符（空格）, 最后用到的是27个字符，所以下边给出一个实用点的。
{% highlight c %}
unsigned int Hash(const char *Key, int TableSize) {
    unsigned int HashVal = 0;
    while (*Key != '\0') {
        HashVal = (HashVal &lt;&lt; 5) ^ *Key++;
    }
    return HashVal % TableSize;
}
{% endhighlight %}

用HashVal << 5 , 32代替27是为了加速，还有异或同样是为了加速。

32 ^ 2 = 34， 1024 ^ 100 = 1124， 512 ^ 234 = 746，(这里异或和加法效果是一样的)，如果关键字特别长，那么该散列函数计算起来会花费过多时间，而且，还可能会左移出最终结果，随意通常做法是不使用所有字符，可以包括完整字符的部分即可。比如有些人只使用奇数位置上的字符来实现他们的散列函数。这里还有一层想法是：用计算散列函数节省下来的时间来补偿由此产生的对均匀地的分布的轻微干扰。剩下的细节就是解决冲突的消除问题，这个下篇讨论。

传送门：《[解决散列冲突之分离链接法和开放寻址法篇](/2011/08/06/solve-hash-conflict-links-method-and-separation-open-addressing-method/)》